{
  "name": "rag_query_webhook",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-query",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        220,
        300
      ],
      "id": "25303bda-6a97-477f-a4ce-b12b596313f0",
      "name": "Webhook Query"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\nfunction getHeader(headers, key) {\n  if (!headers) return '';\n  const value = headers[key] ?? headers[key.toLowerCase()] ?? headers[key.toUpperCase()];\n  if (Array.isArray(value)) return value[0] || '';\n  return value || '';\n}\n\nfunction normalizeHeaders(headers) {\n  const out = {};\n  Object.entries(headers || {}).forEach(([k, v]) => {\n    out[String(k).toLowerCase()] = Array.isArray(v) ? String(v[0] || '') : String(v || '');\n  });\n  return out;\n}\n\nfunction timingSafeEqual(a, b) {\n  const left = Buffer.from(String(a));\n  const right = Buffer.from(String(b));\n  if (left.length !== right.length) return false;\n  return crypto.timingSafeEqual(left, right);\n}\n\nasync function requestJson(url, init) {\n  const response = await fetch(url, init);\n  const text = await response.text();\n  let payload;\n  try {\n    payload = text ? JSON.parse(text) : {};\n  } catch {\n    payload = { raw: text };\n  }\n  if (!response.ok) {\n    const err = new Error('HTTP ' + response.status + ' from ' + url);\n    err.statusCode = response.status;\n    err.details = payload;\n    throw err;\n  }\n  return payload;\n}\n\nfunction sanitizeHistory(history) {\n  if (!Array.isArray(history)) return [];\n  return history\n    .filter((entry) => entry && (entry.role === 'user' || entry.role === 'assistant') && typeof entry.content === 'string')\n    .slice(-20)\n    .map((entry) => ({ role: entry.role, content: entry.content.slice(0, 4000) }));\n}\n\nasync function run() {\n  const incoming = $input.first();\n  const envelope = incoming.json || {};\n  const headers = normalizeHeaders(envelope.headers || {});\n  const body = envelope.body && typeof envelope.body === 'object' ? envelope.body : {};\n\n  const traceId = getHeader(headers, 'x-rag-trace-id') || body.trace_id || crypto.randomUUID();\n\n  try {\n    const secret = process.env.N8N_WEBHOOK_SHARED_SECRET || '';\n    if (!secret) {\n      const err = new Error('N8N_WEBHOOK_SHARED_SECRET is not set');\n      err.statusCode = 500;\n      err.code = 'MISSING_SECRET';\n      throw err;\n    }\n\n    const timestamp = getHeader(headers, 'x-rag-timestamp');\n    const nonce = getHeader(headers, 'x-rag-nonce');\n    const method = (getHeader(headers, 'x-rag-method') || envelope.method || 'POST').toUpperCase();\n    const path = getHeader(headers, 'x-rag-path') || ('/' + String(envelope.path || '').replace(/^\\/+/, ''));\n    const bodySha = getHeader(headers, 'x-rag-body-sha256');\n    const metaSha = getHeader(headers, 'x-rag-meta-sha256');\n    const signature = getHeader(headers, 'x-rag-signature');\n\n    if (!timestamp || !nonce || !bodySha || !metaSha || !signature) {\n      const err = new Error('Missing signature headers');\n      err.statusCode = 401;\n      err.code = 'MISSING_SIGNATURE_HEADERS';\n      throw err;\n    }\n\n    const skewMs = Math.abs(Date.now() - Number(timestamp));\n    const maxSkewMs = Number(process.env.RAG_SIGNATURE_MAX_SKEW_MS || 300000);\n    if (!Number.isFinite(skewMs) || skewMs > maxSkewMs) {\n      const err = new Error('Signature timestamp outside allowed window');\n      err.statusCode = 401;\n      err.code = 'STALE_SIGNATURE';\n      throw err;\n    }\n\n    const canonical = ['v1', timestamp, nonce, method, path, bodySha, metaSha].join('\\n');\n    const expected = 'v1=' + crypto.createHmac('sha256', secret).update(canonical).digest('hex');\n\n    if (!timingSafeEqual(signature, expected)) {\n      const err = new Error('Invalid webhook signature');\n      err.statusCode = 401;\n      err.code = 'INVALID_SIGNATURE';\n      throw err;\n    }\n\n    const query = typeof body.query === 'string' ? body.query.trim() : '';\n    const sessionId = typeof body.session_id === 'string' ? body.session_id.trim() : '';\n    const history = sanitizeHistory(body.history);\n\n    if (!query) {\n      const err = new Error('query is required');\n      err.statusCode = 400;\n      err.code = 'INVALID_QUERY';\n      throw err;\n    }\n\n    if (!sessionId) {\n      const err = new Error('session_id is required');\n      err.statusCode = 400;\n      err.code = 'INVALID_SESSION';\n      throw err;\n    }\n\n    const ollamaBase = (process.env.OLLAMA_BASE_URL || 'http://127.0.0.1:11434').replace(/\\/$/, '');\n    const qdrantBase = (process.env.QDRANT_URL || '').replace(/\\/$/, '');\n    if (!qdrantBase) {\n      const err = new Error('QDRANT_URL is not configured');\n      err.statusCode = 500;\n      err.code = 'MISSING_QDRANT_URL';\n      throw err;\n    }\n\n    const embedModel = process.env.RAG_EMBED_MODEL || 'nomic-embed-text';\n    const genModel = process.env.RAG_GEN_MODEL || 'qwen2.5:7b-instruct';\n    const topK = Number(process.env.RAG_TOP_K || 6);\n    const threshold = Number(process.env.RAG_RETRIEVAL_SCORE_THRESHOLD || 0.72);\n    const minSearchScore = Number(process.env.RAG_MIN_SEARCH_SCORE || 0.2);\n    const qdrantCollection = process.env.QDRANT_COLLECTION || 'knowledge_base';\n\n    const embeddingResponse = await requestJson(ollamaBase + '/api/embeddings', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ model: embedModel, prompt: query }),\n    });\n\n    const vector = embeddingResponse.embedding\n      || (Array.isArray(embeddingResponse.data) && embeddingResponse.data[0] && embeddingResponse.data[0].embedding)\n      || null;\n\n    if (!Array.isArray(vector) || vector.length === 0) {\n      const err = new Error('Embedding model returned no vector');\n      err.statusCode = 502;\n      err.code = 'EMBEDDING_FAILED';\n      throw err;\n    }\n\n    const qdrantHeaders = { 'Content-Type': 'application/json' };\n    if (process.env.QDRANT_API_KEY) {\n      qdrantHeaders['api-key'] = process.env.QDRANT_API_KEY;\n    }\n\n    const searchResponse = await requestJson(\n      qdrantBase + '/collections/' + encodeURIComponent(qdrantCollection) + '/points/search',\n      {\n        method: 'POST',\n        headers: qdrantHeaders,\n        body: JSON.stringify({\n          vector,\n          limit: topK,\n          with_payload: true,\n          with_vector: false,\n          score_threshold: minSearchScore,\n        }),\n      },\n    );\n\n    const matches = Array.isArray(searchResponse.result) ? searchResponse.result : [];\n    const confidence = Number(matches[0]?.score || 0);\n\n    const contextBlocks = matches\n      .map((match, index) => {\n        const payload = match.payload || {};\n        const text = payload.text || payload.chunk || payload.content || '';\n        if (!text || typeof text !== 'string') return null;\n        return '[' + (index + 1) + '] ' + text.slice(0, 1600);\n      })\n      .filter(Boolean);\n\n    const conversationText = history\n      .map((entry) => entry.role.toUpperCase() + ': ' + entry.content)\n      .join('\\n');\n\n    const prompt = [\n      'You are an assistant for personal and company knowledge retrieval.',\n      'Follow these rules:',\n      '1. Prefer retrieved context first.',\n      '2. If retrieval is weak, you may use concise general context but do not claim it came from documents.',\n      '3. Do not output citations.',\n      '',\n      'Conversation history:',\n      conversationText || '(empty)',\n      '',\n      'Retrieved context:',\n      contextBlocks.length ? contextBlocks.join('\\n\\n') : '(no strong context)',\n      '',\n      'User question:',\n      query,\n      '',\n      'Write a concise helpful answer.',\n    ].join('\\n');\n\n    const generationResponse = await requestJson(ollamaBase + '/api/generate', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        model: genModel,\n        prompt,\n        stream: false,\n        options: {\n          temperature: 0.2,\n        },\n      }),\n    });\n\n    const answer = String(\n      generationResponse.response\n      || generationResponse.message?.content\n      || generationResponse.output\n      || '',\n    ).trim();\n\n    if (!answer) {\n      const err = new Error('Generation model returned empty answer');\n      err.statusCode = 502;\n      err.code = 'GENERATION_FAILED';\n      throw err;\n    }\n\n    const mode = confidence >= threshold && contextBlocks.length > 0\n      ? 'grounded'\n      : 'grounded_plus_general';\n\n    return [{\n      json: {\n        statusCode: 200,\n        body: {\n          answer,\n          mode,\n          confidence: Math.max(0, Math.min(1, confidence)),\n          trace_id: traceId,\n          retrieval_count: matches.length,\n        },\n      },\n    }];\n  } catch (error) {\n    const statusCode = Number(error.statusCode || 500);\n    const code = error.code || (statusCode >= 500 ? 'INTERNAL_ERROR' : 'REQUEST_FAILED');\n\n    return [{\n      json: {\n        statusCode,\n        body: {\n          error: {\n            code,\n            message: error.message || 'Unknown error',\n            trace_id: traceId,\n            details: error.details || undefined,\n          },\n        },\n      },\n    }];\n  }\n}\n\nreturn run();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        300
      ],
      "id": "11a922eb-4012-4792-9e85-9f79b41eba7a",
      "name": "Process Query"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.body}}",
        "options": {
          "responseCode": "={{$json.statusCode || 200}}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        820,
        300
      ],
      "id": "ff8a3b8d-4ae3-4315-a2c5-4f06743c2525",
      "name": "Respond Query"
    }
  ],
  "connections": {
    "Webhook Query": {
      "main": [
        [
          {
            "node": "Process Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Query": {
      "main": [
        [
          {
            "node": "Respond Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "staticData": null,
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "active": false
}
